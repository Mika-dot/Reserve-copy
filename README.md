# MD5

MD5 (англ. Message Digest 5) — 128-битный алгоритм хеширования, разработанный профессором Рональдом Л. Ривестом из Массачусетского технологического института (Massachusetts Institute of Technology, MIT) в 1991 году. Предназначен для создания «отпечатков» или дайджестов сообщения произвольной длины и последующей проверки их подлинности. Широко применялся для проверки целостности информации и хранения хешей паролей.

## Алгоритм MD5
На вход алгоритма поступает входной поток данных, хеш которого необходимо найти. Длина сообщения измеряется в битах и может быть любой (в том числе нулевой). Запишем длину сообщения в L. Это число целое и неотрицательное. Кратность каким-либо числам необязательна. После поступления данных идёт процесс подготовки потока к вычислениям.

Ниже приведены 5 шагов алгоритма

### Шаг 1. Выравнивание потока

Сначала к концу потока дописывают единичный бит.

Затем добавляют некоторое число нулевых бит такое, чтобы новая длина потока {\displaystyle L'}L' стала сравнима с 448 по модулю 512, ({\displaystyle L'=512\times N+448}L'=512\times N+448). Выравнивание происходит в любом случае, даже если длина исходного потока уже сравнима с 448.

### Шаг 2. Добавление длины сообщения

В конец сообщения дописывают 64-битное представление длины данных (количество бит в сообщении) до выравнивания. Сначала записывают младшие 4 байта, затем старшие. Если длина превосходит {\displaystyle 2^{64}-1}2^{64}-1, то дописывают только младшие биты (эквивалентно взятию по модулю {\displaystyle 2^{64}}2^{64}). После этого длина потока станет кратной 512. Вычисления будут основываться на представлении этого потока данных в виде массива слов по 512 бит.

### Шаг 3. Инициализация буфера

Для вычислений инициализируются четыре переменные размером по 32 бита, начальные значения которых задаются шестнадцатеричными числами (порядок байтов little-endian):

А = 01 23 45 67; // 67452301h
В = 89 AB CD EF; // EFCDAB89h
С = FE DC BA 98; // 98BADCFEh
D = 76 54 32 10. // 10325476h

В этих переменных будут храниться результаты промежуточных вычислений. Начальное состояние ABCD называется инициализирующим вектором.

### Шаг 4. Вычисление в цикле

Определим функции и константы, которые понадобятся нам для вычислений.

Для каждого раунда потребуется своя функция. Введём функции от трёх параметров — слов, результатом также будет слово:
1-й этап: {\displaystyle \operatorname {FunF} (X,Y,Z)=(X\wedge Y)\vee (\neg X\wedge Z)}\operatorname {FunF} (X,Y,Z)=(X\wedge Y)\vee (\neg X\wedge Z),
2-й этап: {\displaystyle \operatorname {FunG} (X,Y,Z)=(X\wedge Z)\vee (\neg Z\wedge Y)}\operatorname {FunG} (X,Y,Z)=(X\wedge Z)\vee (\neg Z\wedge Y),
3-й этап: {\displaystyle \operatorname {FunH} (X,Y,Z)=X\oplus Y\oplus Z}\operatorname {FunH} (X,Y,Z)=X\oplus Y\oplus Z,
4-й этап: {\displaystyle \operatorname {FunI} (X,Y,Z)=Y\oplus (\neg {Z}\vee X)}\operatorname {FunI} (X,Y,Z)=Y\oplus (\neg {Z}\vee X),
где {\displaystyle \oplus ,\wedge ,\vee ,\neg }\oplus ,\wedge ,\vee ,\neg  побитовые логические операции XOR, AND, OR и NOT соответственно.

Определим таблицу констант {\displaystyle T[1\ldots 64]}T[1\ldots 64] — 64-элементная таблица данных, построенная следующим образом: {\displaystyle T[n]=\operatorname {int} (2^{32}\cdot |\sin n|)}T[n]=\operatorname {int} (2^{32}\cdot |\sin n|).

Каждый 512-битный блок проходит 4 этапа вычислений по 16 раундов. Для этого блок представляется в виде массива X из 16 слов по 32 бита. Все раунды однотипны и имеют вид: [abcd k s i], определяемый как {\displaystyle a=b+((a+\operatorname {Fun} (b,c,d)+X[k]+T[i])\lll s)}a=b+((a+\operatorname {Fun} (b,c,d)+X[k]+T[i])\lll s), где k — номер 32-битного слова из текущего 512-битного блока сообщения, и {\displaystyle \ldots \lll s}\ldots \lll s — циклический сдвиг влево на s бит полученного 32-битного аргумента. Число s задается отдельно для каждого раунда.

Заносим в блок данных элемент n из массива 512-битных блоков. Сохраняются значения A, B, C и D, оставшиеся после операций над предыдущими блоками (или их начальные значения, если блок первый).

AA = A
BB = B
CC = C
DD = D
